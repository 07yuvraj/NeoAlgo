From ac04ab8642c338a2ba1dde90e6a76c8073be4988 Mon Sep 17 00:00:00 2001
From: Kritika37 <Kritikasagar1999@gmail.com>
Date: Sun, 16 Aug 2020 15:04:59 +0530
Subject: [PATCH] CPatch file for postorder cpp hakincodes

---
 C-Plus-Plus/README.md        |   1 +
 C-Plus-Plus/ds/postorder.cpp | 118 +++++++++++++++++++++++++++++++++++
 2 files changed, 119 insertions(+)
 create mode 100644 C-Plus-Plus/ds/postorder.cpp

diff --git a/C-Plus-Plus/README.md b/C-Plus-Plus/README.md
index e56131f..3a38c75 100644
--- a/C-Plus-Plus/README.md
+++ b/C-Plus-Plus/README.md
@@ -13,6 +13,7 @@
 
 - [Binary Search Tree](ds/BinarySearchTree.cpp)
 - [Binary Tree](ds/BinaryTree.cpp)
+- [Binary Tree](ds/postorder.cpp)
 - [Doubly Linked List](ds/DoublyLinkedList.cpp)
 - [Hashtable with separate chaining](ds/Hashing_with_chaining.cpp)
 - [Linked List](ds/LinkedList.cpp)
diff --git a/C-Plus-Plus/ds/postorder.cpp b/C-Plus-Plus/ds/postorder.cpp
new file mode 100644
index 0000000..afb9e69
--- /dev/null
+++ b/C-Plus-Plus/ds/postorder.cpp
@@ -0,0 +1,118 @@
+#include <iostream>
+#include <cstdlib>
+#include<stack>
+using namespace std;
+
+struct tree {               // treenode
+    int data;
+    tree *Left, *Right;
+};
+
+tree* root;
+class Binarytree {
+public:
+    Binarytree();
+    void create(int);
+    tree* insert(tree*, tree*);
+    void postnonrec(tree*);
+    void postraversal(tree*);
+};
+Binarytree::Binarytree()
+{
+    root = NULL;
+}
+
+tree* Binarytree::insert(tree* temp, tree* newnode)
+{
+    if (temp == NULL) {
+        temp = newnode;
+    }
+    else if (temp->data < newnode->data) {
+        insert(temp->Right, newnode);
+        if (temp->Right == NULL)
+            temp->Right = newnode;
+    }
+    else {
+        insert(temp->Left, newnode);
+        if (temp->Left == NULL)
+            temp->Left = newnode;
+    }
+    return temp;
+}
+void Binarytree::create(int n)
+{
+    tree *temp = root, *newnode;
+    newnode = new tree;
+    newnode->Left = NULL;
+    newnode->Right = NULL;
+    newnode->data = n;
+    root = insert(temp, newnode);
+}
+void Binarytree::postnonrec(tree* t = root) // non recursive traversal
+{
+        tree *temp;
+        stack<tree *> s;
+        temp = root;
+        while(true){
+            if(temp != NULL){
+                s.push(temp);
+                temp = temp->Left;   //visting left subtree
+            }
+            else
+            {
+                if(s.empty()) break;
+                temp = s.top()->Right;
+                if(temp == NULL){
+                    tree *last = NULL;
+                    while(!s.empty() && s.top()->Right == last){
+                        last = s.top();
+                        s.pop();
+                        cout<<last->data<<" ";
+                    }
+                }
+            }
+        }
+            
+        
+}
+
+void Binarytree::postraversal(tree* t = root) //recursive traversal
+{
+    if (root == NULL) {
+        cout << "Tree is empty";
+    }
+    else if (t != NULL) {
+        postraversal(t->Left);
+        postraversal(t->Right);
+        cout << t->data << " ";
+    }
+}
+
+int main()
+{
+    Binarytree bt;
+    int choice, n, key;
+    while (1) {
+        cout << "\n\t1. Insert\n\t2. Non recursive Post Traversal\n\t3. Postorder Traversal\n\t4. Exit" << endl;
+        cout << "Enter your choice: ";
+        cin >> choice;
+        switch (choice) {
+        case 1:
+            cout << "Enter Node to be inserted: ";
+            cin >> n;
+            bt.create(n);
+            break;
+        case 2:
+            cout << endl;
+            bt.postnonrec();
+            break;
+        case 3:
+            cout << endl;
+            bt.postraversal();
+            break;
+        case 4:
+            exit(0);
+        }
+    }
+    return 0;
+}
\ No newline at end of file
-- 
2.17.1

